#!/usr/bin/env php
<?php

if ( PHP_SAPI !== 'cli' ) {
	die( "This is not a valid entry point.\n" );
}

require( __DIR__ . '/src/RedisJobService.php' );

RedisJobService::checkEnvironment();

class RedisJobChronService extends RedisJobService {
	const HOT_QUEUE_TTL = 1800; // TTL on queue hotness
	const COLD_QUEUE_FACTOR = 10; // check non-hot queues 1/X times
	const LUA_WAIT_US = 5000; // time to wait between LUA scripts
	const SYNC_DELAY = 10; // min time between syncAggregatorRegistry()

	/** @var integer[] Map of (encoded queue name => UNIX timestamp) */
	private $hotQueueMap = array();
	/** @var integer Number of executePeriodicTasks() calls completed */
	private $periodicTaskRounds = 0;

	/**
	 * Entry point method that starts the service in earnest and keeps running
	 */
	public function main() {
		$this->notice( "Starting job chron loop(s)..." );

		$host = gethostname();

		// Setup signal handlers...
		$handlerFunc = function( $signo ) {
			print "Caught signal ($signo)\n";
			exit( 128 + $signo );
		};
		$ok = pcntl_signal( SIGHUP, $handlerFunc )
			&& pcntl_signal( SIGINT, $handlerFunc )
			&& pcntl_signal( SIGTERM, $handlerFunc );
		if ( !$ok ) {
			throw new Exception( 'Could not install singal handlers.' );
		}

		$lastSyncTime = 0;
		$memLast = memory_get_usage();
		$this->incrStats( "start-chron.$host", 1 );
		while ( true ) {
			pcntl_signal_dispatch();

			if ( ( time() - $lastSyncTime ) > self::SYNC_DELAY ) {
				$lastSyncTime = time();
				$count = $this->syncAggregatorRegistry();
				$this->notice( "Synced $count aggregator(s) to the current one." );
				$this->incrStats( "periodictasks.sync.$host", 1 );
			}

			$count = $this->executePeriodicTasks();
			$this->notice( "Updated the state of $count job(s) (recycle/undelay/abandon)." );

			sleep( 1 );

			// Track memory usage
			$memCurrent = memory_get_usage();
			$this->debug( "Memory usage: $memCurrent bytes." );
			$this->incrStats( "memory.$host", $memCurrent - $memLast );
			$memLast = $memCurrent;
		}
	}

	/**
	 * Merge wiki and queue type registration data into all aggregators
	 *
	 * This makes sure that the data is not lost on aggregator failure
	 *
	 * @return integer Servers fully updated
	 */
	private function syncAggregatorRegistry() {
		$count = count( $this->aggrSrvs );

		try {
			$types = $this->redisCmdHA(
				$this->aggrSrvs,
				'hGetAll',
				array( $this->getQueueTypesKey() )
			);
			if ( $types ) {
				$okCount = $this->redisCmdBroadcast(
					$this->aggrSrvs,
					'hMSet',
					array( $this->getQueueTypesKey(), $types )
				);
				$count = min( $count, $okCount );
			}

			$wikis = $this->redisCmdHA(
				$this->aggrSrvs,
				'sMembers',
				array( $this->getWikiSetKey() )
			);
			if ( $wikis ) {
				$okCount = $this->redisCmdBroadcast(
					$this->aggrSrvs,
					'sAdd',
					array_merge( array( $this->getWikiSetKey() ), $wikis )
				);
				$count = min( $count, $okCount );
			}
		} catch ( RedisExceptionHA $e ) {
			$count = 0;
		}

		return $count;
	}

	/**
	 * Recycle or destroy any jobs that have been claimed for too long
	 * and release any ready delayed jobs into the queue. Also abandon
	 * and prune out jobs that failed too many times. This updates the
	 * aggregator server as necessary.
	 *
	 * @return int|bool Number of jobs recycled/deleted/undelayed/abandoned (false if not run)
	 */
	private function executePeriodicTasks() {
		$jobs = 0;

		$host = gethostname();

		$ok = true;
		try {
			// Only let a limited number of services do this at once
			$lockKey = $this->poolLock( __METHOD__, count( $this->queueSrvs ), 300 );
			if ( $lockKey === false ) {
				$this->incrStats( "periodictasks.raced.$host", 1 );
				$this->notice( "Raced out of periodic tasks." );
				return $jobs;
			}

			$this->incrStats( "periodictasks.claimed.$host", 1 );

			$types = $this->redisCmdHA(
				$this->aggrSrvs,
				'hKeys',
				array( $this->getQueueTypesKey() )
			);
			$wikiIds = $this->redisCmdHA(
				$this->aggrSrvs,
				'sMembers',
				array( $this->getWikiSetKey() )
			);

			if ( is_array( $types ) && is_array( $wikiIds ) ) {
				// Job queue partition servers
				$qServers = $this->queueSrvs;
				// Randomize to scale the liveliness with the # of runners
				shuffle( $types );
				shuffle( $wikiIds );
				shuffle( $qServers );

				// Build up the script arguments for each queue
				// using an Iterator to avoid client OOMs...
				$paramsByQueue = new AppendIterator();
				foreach ( $types as $type ) {
					$paramsByQueue->append( new PeriodicScriptParamsIterator(
						$type,
						$wikiIds,
						$this->getTTLForType( $type ),
						$this->getAttemptsForType( $type )
					) );
				}

				// Track queues that become "ready"
				$mapSet = array(); // map of (queue name => timestamp)
				// Run the script on all job queue partitions...
				foreach ( $qServers as $qServer ) {
					$ok = $this->updateQueueServer(
						$qServer, $paramsByQueue, $mapSet, $jobs, $lockKey
					) && $ok;
				}
				// Update the map in the aggregator as queues become ready
				$this->redisCmdHA(
					$this->aggrSrvs,
					'hMSet',
					array( $this->getReadyQueueKey(), $mapSet )
				);
			} else {
				$ok = false;
			}

			// Release the pool lock
			$this->poolUnlock( $lockKey );

			++$this->periodicTaskRounds;
		} catch ( RedisExceptionHA $e ) {
			$ok = false;
		}

		if ( $ok ) {
			$this->incrStats( "periodictasks.done.$host", 1 );
		} else {
			$this->incrStats( "periodictasks.failed.$host", 1 );
			$this->error( "Failed to do periodic tasks for some queues." );
		}

		return $jobs;
	}

	/**
	 * @param string $qServer
	 * @param Iterator $paramsByQueue PeriodicScriptParamsIterator conforming generator
	 * @param array $mapSet Map of (queue name => timestamp)
	 * @param integer $jobs
	 * @param string $lockKey
	 * @return bool
	 */
	private function updateQueueServer(
		$qServer, Iterator $paramsByQueue, array &$mapSet, &$jobs, $lockKey
	) {
		$ok = true;

		$allQueuesScanned = ( $this->periodicTaskRounds > 1 );

		$queuesChecked = 0;
		$scriptLoaded = false; // load LUA script only once per server round
		foreach ( $paramsByQueue as $params ) {
			list( $qType, $qWiki ) = $params['queue'];
			$encQueue = $this->encQueueName( $qType, $qWiki );
			if ( $allQueuesScanned
				&& !isset( $this->hotQueueMap[$encQueue] )
				&& mt_rand( 1, self::COLD_QUEUE_FACTOR ) != 1
			) {
				$this->debug( "Skipped non-hot queue '$qType/$qWiki'." );
				continue; // non-hot queues are ignored most rounds
			}

			$affected = 0;
			$paramsByQueueBatch = array( $params ); // batches of 1
			$ok = $this->updateQueueServerChunk(
				$qServer, $paramsByQueueBatch, $mapSet, $affected, $scriptLoaded
			) && $ok;

			usleep( self::LUA_WAIT_US ); // avoid CPU hogging

			if ( $affected > 0 ) {
				$this->hotQueueMap[$encQueue] = time();
				$this->debug( "Listed hot queue '$qType/$qWiki." );
			} elseif ( isset( $this->hotQueueMap[$encQueue] )
				&& ( time() - $this->hotQueueMap[$encQueue] ) > self::HOT_QUEUE_TTL
			)  {
				unset( $this->hotQueueMap[$encQueue] );
				$this->debug( "Delisted non-hot queue '$qType/$qWiki'." );
			}

			$jobs += $affected;

			// Don't let the pool lock expire mid-run
			if ( ++$queuesChecked % 100 == 0 ) {
				$this->poolRefreshLock( $lockKey );
			}
		}

		return $ok;
	}

	/**
	 * @param string $qServer
	 * @param array $paramsByQueue Chunk of results from PeriodicScriptParamsIterator
	 * @param array $mapSet Map of (queue name => timestamp)
	 * @param integer $jobs
	 * @param bool $scriptLoaded
	 * @return bool
	 */
	private function updateQueueServerChunk(
		$qServer, array $paramsByQueue, array &$mapSet, &$jobs, &$scriptLoaded
	) {
		$host = gethostname();

		$qConn = $this->getRedisConn( $qServer );
		if ( !$qConn ) {
			$this->incrStats( "periodictasks.failed.$host", count( $paramsByQueue ) );
			return false; // partition down
		}

		// Load the LUA script into memory if needed
		$script = PeriodicScriptParamsIterator::getChronScript();
		if ( $scriptLoaded ) {
			$sha1 = sha1( $script );
		} else {
			$sha1 = $this->redisCmd( $qConn, 'script', array( 'load', $script ) );
			$scriptLoaded = true;
		}

		$failed = 0;
		try {
			$this->redisCmd( $qConn, 'multi', array( Redis::PIPELINE ) );
			foreach ( $paramsByQueue as $params ) {
				$this->redisCmd( $qConn, 'evalSha',
					array( $sha1, $params['params'], $params['keys'] ) );
			}
			$res = $this->redisCmd( $qConn, 'exec' );

			$now = time();
			foreach ( $res as $i => $result ) {
				if ( !$result ) {
					++$failed;
					continue;
				}
				list( $qType, $qWiki ) = $paramsByQueue[$i]['queue'];
				list( $released, $abandoned, $pruned, $undelayed, $ready ) = $result;
				if ( $released > 0 || $undelayed > 0 || $ready > 0 ) {
					// This checks $ready to handle lost aggregator updates as well as
					// to merge after network partitions that caused aggregator fail-over.
					$mapSet[$this->encQueueName( $qType, $qWiki )] = $now;
				}
				$jobs += ( array_sum( $result ) - $ready );
				$this->incrStats( "job-recycle.$qType", $released );
				$this->incrStats( "job-abandon.$qType", $abandoned );
				$this->incrStats( "job-undelay.$qType", $undelayed );
				$this->incrStats( "job-prune.$qType", $pruned );
			}
		} catch ( RedisException $e ) {
			$failed += count( $paramsByQueue );
			$this->handleRedisError( $e, $qServer );
		}

		$this->incrStats( "periodictasks.failed.$host", $failed );

		return ( $failed == 0 );
	}

	/**
	 * @param string $name
	 * @param integer $slots
	 * @param integer $ttl
	 * @return string|bool Lock key or false
	 */
	private function poolLock( $name, $slots, $ttl ) {
		for ( $i=0; $i < $slots; ++$i ) {
			$key = "$name:lock:$i";
			$now = microtime( true );

			$oldLock = $this->redisCmdHA( $this->aggrSrvs, 'get', array( $key ) );
			if ( $oldLock === false || $oldLock < ( $now - $ttl ) ) {
				$casLock = $this->redisCmdHA( $this->aggrSrvs, 'getset', array( $key, $now ) );
				if ( $casLock == $oldLock ) {
					return $key;
				}
			}
		}

		return false;
	}

	/**
	 * @param string $key
	 * @return bool
	 */
	private function poolRefreshLock( $key ) {
		return $this->redisCmdHA( $this->aggrSrvs, 'set', array( $key, microtime( true ) ) );
	}

	/**
	 * @param string $key
	 * @return bool
	 */
	private function poolUnlock( $key ) {
		return (bool)$this->redisCmdHA( $this->aggrSrvs, 'delete', array( $key ) );
	}

	/**
	 * @param string $type Queue type
	 * @return integer Seconds
	 */
	protected function getTTLForType( $type ) {
		return isset( $this->claimTTLMap[$type] )
			? $this->claimTTLMap[$type]
			: $this->claimTTLMap['*'];
	}

	/**
	 * @param string $type Queue type
	 * @return integer
	 */
	protected function getAttemptsForType( $type ) {
		return isset( $this->attemptsMap[$type] )
			? $this->attemptsMap[$type]
			: $this->attemptsMap['*'];
	}
}

class PeriodicScriptParamsIterator implements Iterator {
	private $type;
	private $domains;
	private $claimTTL;
	private $maxAttempts;

	/**
	 * @param string $type Queue/job type
	 * @param array $domains Domain IDs
	 * @param integer $claimTTL Claim TTL
	 * @param integer $maxAttempts Max job attempts
	 */
	public function __construct( $type, array $domains, $claimTTL, $maxAttempts ) {
		$this->type = $type;
		$this->domains = $domains;
		$this->claimTTL = $claimTTL;
		$this->maxAttempts = $maxAttempts;
	}

	function rewind() {
		reset( $this->domains );
	}

	function current() {
		$domain = current( $this->domains );
		if ( $domain === false ) {
			return false;
		}
		$now = time();

		return array(
			'queue'  => array( $this->type, $domain ),
			'params' => array(
				"{$domain}:jobqueue:{$this->type}:z-claimed", # KEYS[1]
				"{$domain}:jobqueue:{$this->type}:h-attempts", # KEYS[2]
				"{$domain}:jobqueue:{$this->type}:l-unclaimed", # KEYS[3]
				"{$domain}:jobqueue:{$this->type}:h-data", # KEYS[4]
				"{$domain}:jobqueue:{$this->type}:z-abandoned", # KEYS[5]
				"{$domain}:jobqueue:{$this->type}:z-delayed", # KEYS[6]
				$now - $this->claimTTL, # ARGV[1]
				$now - 7 * 86400, # ARGV[2]
				$this->maxAttempts, # ARGV[3]
				$now # ARGV[4]
			),
			'keys'   => 6 # number of first argument(s) that are keys
		);
	}

	function key() {
		return key( $this->domains );
	}

	function next() {
		next( $this->domains );
	}

	function valid() {
		return key( $this->domains ) !== null;
	}

	/**
	 * @return string
	 */
	public static function getChronScript() {
		static $script =
		<<<LUA
		local kClaimed, kAttempts, kUnclaimed, kData, kAbandoned, kDelayed = unpack(KEYS)
		local rClaimCutoff, rPruneCutoff, rAttempts, rTime = unpack(ARGV)
		local released,abandoned,pruned,undelayed,ready = 0,0,0,0,0
		-- Short-circuit if there is nothing at all in the queue
		if redis.call('exists',kData) == 0 then
			return {released,abandoned,pruned,undelayed,ready}
		end
		-- Get all non-dead jobs that have an expired claim on them.
		-- The score for each item is the last claim timestamp (UNIX).
		local staleClaims = redis.call('zRangeByScore',kClaimed,0,rClaimCutoff)
		for k,id in ipairs(staleClaims) do
			local timestamp = redis.call('zScore',kClaimed,id)
			local attempts = 1*redis.call('hGet',kAttempts,id)
			if attempts < 1*rAttempts then
				-- Claim expired and attempts left: re-enqueue the job
				redis.call('rPush',kUnclaimed,id)
				released = released + 1
			else
				-- Claim expired and no attempts left: mark the job as dead
				redis.call('zAdd',kAbandoned,timestamp,id)
				abandoned = abandoned + 1
			end
			redis.call('zRem',kClaimed,id)
		end
		-- Get all of the dead jobs that have been marked as dead for too long.
		-- The score for each item is the last claim timestamp (UNIX).
		local deadClaims = redis.call('zRangeByScore',kAbandoned,0,rPruneCutoff)
		for k,id in ipairs(deadClaims) do
			-- Stale and out of attempts: remove any traces of the job
			redis.call('zRem',kAbandoned,id)
			redis.call('hDel',kAttempts,id)
			redis.call('hDel',kData,id)
			pruned = pruned + 1
		end
		-- Get the list of ready delayed jobs, sorted by readiness (UNIX timestamp)
		local ids = redis.call('zRangeByScore',kDelayed,0,rTime)
		-- Migrate the jobs from the "delayed" set to the "unclaimed" list
		for k,id in ipairs(ids) do
			redis.call('lPush',kUnclaimed,id)
			redis.call('zRem',kDelayed,id)
		end
		undelayed = #ids
		ready = redis.call('lLen',kUnclaimed)
		return {released,abandoned,pruned,undelayed,ready}
LUA;

		return $script;
	}
}

error_reporting( E_ALL | E_STRICT );
ini_set( 'display_errors', 1 );

// Run the server...
set_time_limit( 0 );
ini_set( 'memory_limit', '256M' );
RedisJobChronService::init(
	getopt( '', array( 'config-file::', 'help', 'verbose' ) )
)->main();
