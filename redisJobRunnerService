#!/usr/bin/env php
<?php
#
# NAME
# redisJobRunnerService -- Continuously process a MediaWiki jobqueue
#
# DESCRIPTION
# redisJobRunnerService is an infinite "while loop" used to call MediaWiki runJobs.php
# and eventually attempt to process any job enqueued. A number of virtual sub-loops with
# their own runners and job types must be defined via parameters. These loops can set any
# of the job types as either low or high priorty. High priority will get ~80% of the time
# share of the sub-loop under "busy" conditions. If there are few high priority jobs, the
# loops will spend much more of their time on the low priority ones.
#
# This script is normally ran from the $IP directory of MediaWiki.
# The --wrapper parameter is used to run some wrapper with a given command
# by passing runJobs.php and the rest of the parameters as arguments to it.
# For example, the value "php MWScript.php" could be used.
#
# You will probably want to run this script under your webserver username.
#
# Example:
# // Process jobs of type "webVideoTranscode" with a maxtime of 4 hours with 5 runners
# redisJobRunnerService --aggrSrvs <h:p> --queueSrvs <h:p> --timeout 14400 --runners 5:webVideoTranscode
#
# // Process jobs of type "AssembleUploadChunks"/"PublishedStashedFile" with 2 runners
# redisJobRunnerService --aggrSrvs <h:p> --queueSrvs <h:p> --runners "5:AssembleUploadChunks,PublishedStashedFile'
#
# // Process jobs of type "A"/"B" with 2 runners and "C"/"D" with 2 runners
# redisJobRunnerService --aggrSrvs <h:p> --queueSrvs <h:p> --runners "5:A,B|3:C,D"
#
# // Process jobs of all runners except refreshLinks/null and deprioritize renameUser
# redisJobRunnerService --aggrSrvs <h:p> --queueSrvs <h:p> --runners "5:*,-refreshLinks,-null,~renameUser"
#
if ( PHP_SAPI !== 'cli' ) {
	die( "This is not a valid entry point.\n" );
}

error_reporting( E_ALL );

// Run the server...
set_time_limit( 0 );
ini_set( 'memory_limit', '256M' );
RedisJobRunnerService::init(
	getopt( '', array(
		'aggrSrvs:', 'queueSrvs:', 'runners:',
		'config-file::', 'wrapper::', 'claimTTL::', 'attempts::', 'maxReal::', 'maxMem::',
		'statsdAddr::',
		'verbose', 'help'
	) )
)->main();

class RedisJobRunnerService {
	/**
	 * How long can low priority jobs be run until some high priority
	 * jobs should be checked for and run if they exist.
	 * @var integer
	 */
	protected $hpMaxDelay = 120;
	/**
	 * The maxtime parameter for runJobs.php for low priority jobs.
	 * The lower this value is, the less jobs of one wiki can hog attention
	 * from the jobs on other wikis, though more overhead is incurred.
	 * This should be lower than hpmaxdelay.
	 * @var integer
	 */
	protected $lpMaxTime = 60;
	/**
	 * How long can high priority jobs be run until some low priority
	 * jobs should be checked for and run if they exist.
	 * @var integer
	 */
	protected $lpMaxDelay = 600;
	/**
	 * The maxtime parameter for runJobs.php for high priority jobs.
	 * The lower this value is, the less jobs of one wiki/type can hog attention
	 * from jobs of another wiki/type, though more overhead is incurred.
	 * This should be lower than lpmaxdelay.
	 * @var integer
	 */
	protected $hpMaxTime = 30;

	/** @var Array List of IP:<port> entries */
	protected $queueSrvs = array();
	/** @var Array List of IP:<port> entries */
	protected $aggrSrvs = array();
	/** @var string Redis password */
	protected $password;

	/** @var bool */
	protected $verbose;
	/** @var string MediaWiki script wrapper */
	protected $wrapper;
	/** @var Map of (id => (job type list,count) */
	protected $loopMap = array();
	/** @var Map of (job type => integer seconds) */
	protected $claimTTLMap = array();
	/** @var Map of (job type => integer) */
	protected $attemptsMap = array();
	/** @var Map of (job type => integer) */
	protected $maxRealMap = array();
	/** @var Map of (job type => integer) */
	protected $maxMemMap = array();
	/** @var String IP address or hostname */
	protected $statsdHost;
	/** @var integer Port number */
	protected $statsdPort;

	/** @var Map of (server => Redis object) */
	protected $conns = array();
	/** @var Map of (server => timestamp) */
	protected $downSrvs = array();

	/** @var RedisJobRunnerService */
	protected static $instance;

	/**
	 * @param array $config
	 * @return RedisJobRunnerService
	 * @throws Exception
	 */
	public static function init( array $config ) {
		if ( self::$instance ) {
			throw new Exception( 'RedisJobRunnerService already initialized.' );
		}

		if ( isset( $config['config-file'] ) ) {
			$iniConfig = parse_ini_file( $config['config-file'] );
			if ( is_array( $iniConfig ) ) {
				$config += $iniConfig; // params take precedence
			} else {
				throw new Exception( "Could not parse file at '{$config['config-file']}'." );
			}
		}

		foreach ( array( 'aggrSrvs', 'queueSrvs', 'runners' ) as $par ) {
			if ( !isset( $config[$par] ) || isset( $config['help'] ) ) {
				die( "Usage: php RedisJobRunnerService.php\n" .
					"--config-file=<path>\n" .
					"--aggrSrvs=<address>[,address]...\n" .
					"--queueSrvs=<address>[,address]...>\n" .
					"--runners=<count>:<type>[,type]...[|<count>:<type>[,type]...]...\n" .
					"--wrapper=<script wrapper>" .
					"--claimTTL=<type>:<seconds>[,<type>:<seconds>]...\n" .
					"--attempts=<type>:<integer>[,<type>:<integer>]...\n" .
					"--maxReal=<type>:<integer>[,<type>:<integer>]...\n" .
					"--maxMem=<type>:<integer>[,<type>:<integer>(B|M)]...\n" .
					"--statsdAddr=<address>\n"
				);
			}
		}

		self::$instance = new self( $config );
		return self::$instance;
	}

	/**
	 * @param array $config
	 */
	protected function __construct( array $config ) {
		$this->aggrSrvs = explode( ',', $config['aggrSrvs'] );
		if ( !count( $this->aggrSrvs ) ) {
			throw new Exception( "Empty list for 'aggrSrvs'." );
		}
		$this->queueSrvs = explode( ',', $config['queueSrvs'] );
		if ( !count( $this->queueSrvs ) ) {
			throw new Exception( "Empty list for 'queueSrvs'." );
		}

		foreach ( explode( '&', $config['runners'] ) as $loop ) {
			list( $runners, $types ) = explode( ':', trim( $loop ) );
			if ( !preg_match( '/^\d+$/', $runners ) ) {
				throw new Exception( "Invalid number of job runners '$runners'." );
			} elseif ( $runners == 0 ) {
				continue; // loop disabled
			}
			$types = explode( ',', $types );
			foreach ( $types as $type ) {
				$type = trim( $type );
				if ( !preg_match( '/^[-~]?[a-zA-Z0-9]+|\*$/', $type ) ) {
					throw new Exception( "Invalid job type '$type'." );
				}
			}
			$this->loopMap[] = array( 'types' => $types, 'runners' => (int)$runners );
		}

		if ( isset( $config['timeout'] ) ) {
			$this->maxProcReal = (int)$config['timeout'];
		}
		if ( isset( $config['wrapper'] ) ) {
			$this->wrapper = $config['wrapper'];
		}
		if ( isset( $config['password'] ) ) {
			$this->password = $config['password'];
		}
		$this->claimTTLMap['*'] = 3600; // default
		if ( isset( $config['claimTTL'] ) ) {
			$tuples = explode( ',', $config['claimTTL'] );
			foreach ( $tuples as $tuple ) {
				list( $type, $value ) = explode( ':', trim( $tuple ) );
				if ( $value < 30 ) {
					throw new Exception( "Invalid claim TTL '$value'." );
				}
				$this->claimTTLMap[$type] = (int)$value;
			}
		}
		$this->attemptsMap['*'] = 3; // default
		if ( isset( $config['attempts'] ) ) {
			$tuples = explode( ',', $config['attempts'] );
			foreach ( $tuples as $tuple ) {
				list( $type, $value ) = explode( ':', trim( $tuple ) );
				if ( $value < 1 ) {
					throw new Exception( "Invalid max attempts '$value'." );
				}
				$this->attemptsMap[$type] = (int)$value;
			}
		}
		// Avoid killing processes before they get a fair chance to exit
		$minRealTime = 2 * max( $this->lpMaxTime, $this->hpMaxTime );
		$this->maxRealMap['*'] = 3600; // default
		if ( isset( $config['maxReal'] ) ) {
			$tuples = explode( ',', $config['maxReal'] );
			foreach ( $tuples as $tuple ) {
				list( $type, $value ) = explode( ':', trim( $tuple ) );
				$this->maxRealMap[$type] = max( (int)$value, $minRealTime );
			}
		}
		$this->maxMemMap['*'] = '300M'; // default
		if ( isset( $config['maxMem'] ) ) {
			$tuples = explode( ',', $config['maxMem'] );
			foreach ( $tuples as $tuple ) {
				list( $type, $value ) = explode( ':', trim( $tuple ) );
				$this->maxMemMap[$type] = (int)$value;
			}
		}
		if ( isset( $config['statsdAddr'] ) ) {
			$m = array();
			if ( preg_match( '/^(.+):(\d+)$/', $config['statsdAddr'], $m ) ) {
				$this->statsdHost = $m[1];
				$this->statsdPort = (int)$m[2];
			} else {
				throw new Exception( "Invalid profiler address '{$config['statsdAddr']}'." );
			}
		}
		$this->verbose = isset( $config['verbose'] );
	}

	/**
	 * Entry point method that starts the service in earnest and keeps running
	 */
	public function main() {
		$this->notice( "Starting jobs loop(s)..." );

		$prioMap = array(); // map of (id => (current priority, since))
		$procMap = array(); // map of (id => slot # => process handle, descriptors)
		foreach ( $this->loopMap as $id => $info ) {
			for ( $i=0; $i < $info['runners']; ++$i ) {
				$procMap[$id][$i] = array(
					'handle' => false,
					'pipes'  => array(),
					'type'   => null,
					'cmd'    => null,
					'stime'  => 0
				);
				$prioMap[$id] = array( 'high' => true, 'since' => time() );
			}
			$this->notice( "Initialized loop $id with {$info['runners']} runner(s)." );
		}

		// Setup signal handlers
		$handlerFunc = function( $signo ) use ( &$procMap ) {
			print "Caught signal ($signo)\n";
			foreach ( $procMap as $id => &$procSlots ) {
				foreach ( $procSlots as $slot => &$procSlot ) {
					if ( !$procSlot['handle'] ) {
						continue;
					}
					fclose( $procSlot['pipes'][1] );
					fclose( $procSlot['pipes'][2] );
					$status = proc_get_status( $procSlot['handle'] );
					print "Sending SIGTERM to {$status['pid']}.\n";
					proc_terminate( $procSlot['handle'] );
				}
			}
			exit( 128 + $signo );
		};
		$useSignals = function_exists( 'pcntl_signal' );
		if ( $useSignals ) {
			$ok = pcntl_signal( SIGHUP, $handlerFunc )
				&& pcntl_signal( SIGINT, $handlerFunc )
				&& pcntl_signal( SIGTERM, $handlerFunc );
			if ( !$ok ) {
				throw new Exception( 'Could not install singal handlers.' );
			}
		}

		while ( true ) {
			if ( $useSignals ) {
				pcntl_signal_dispatch();
			}

			$anyNew = 0;
			$anyFree = 0;
			$found = false;
			// Do periodic queue tasks on all queues every 5 minutes
			$count = $this->executeReadyPeriodicTasks();
			if ( is_int( $count ) ) {
				$this->notice( "Updated the state of $count job(s) (recycle/undelay/abandon)." );
			}
			// Get the list of ready queues
			$pending = $this->getReadyQueueMap();
			if ( !count( $pending ) ) {
				$this->notice( "No jobs available..." );
				sleep( 5 ); // no jobs
				continue;
			}
			// Spawn new runners as slots become available
			foreach ( $procMap as $id => &$procSlots ) {
				$this->debug( "Checking runner loop $id..." );
				// Implement high/low priority via time-sharing
				if ( $prioMap[$id]['high']
					&& ( time() - $prioMap[$id]['since'] ) > $this->lpMaxDelay
				) {
					$prioMap[$id]['high'] = false;
					$prioMap[$id]['since'] = time();
					$this->debug( "Runner loop $id now in low priority." );
				} elseif ( !$prioMap[$id]['high']
					&& ( time() - $prioMap[$id]['since'] ) > $this->hpMaxDelay
				) {
					$prioMap[$id]['high'] = true;
					$prioMap[$id]['since'] = time();
					$this->debug( "Runner loop $id now in high priority." );
				}
				// Find any free slots and replace them with new processes
				list( $free, $new ) = $this->refillSlots( $id, $procSlots, $prioMap, $pending );
				$anyFree += $free;
				$anyNew += $new;
				// Rotate the priority from high/low and back if no jobs were found
				if ( !$free ) {
					$this->debug( "Runner loop $id is full." );
				} elseif ( !$new ) {
					if ( $prioMap[$id]['high'] ) {
						$prioMap[$id]['high'] = false;
						$this->debug( "Runner loop $id now in low priority." );
					} else {
						$prioMap[$id]['high'] = true;
						$this->debug( "Runner loop $id now in high priority." );
					}
					$prioMap[$id]['since'] = time();
					$this->debug( "Runner loop $id has no jobs." );
				} else {
					$this->debug( "Done checking loop $id." );
				}
			}
			// Backoff if there is nothing to do
			if ( !$anyFree ) {
				$this->debug( "All runner loops full." );
				usleep( 100000 );
			} elseif ( !$anyNew ) {
				$this->debug( "Loops have free slots, but there are no appropriate jobs." );
				usleep( 1000000 );
			}
			$this->debug( "Memory usage: " . memory_get_usage() . "." );
		}
	}

	/**
	 * @param integer $id
	 * @param array $procSlots
	 * @param array $prioMap
	 * @param array $pending
	 * @return array
	 */
	protected function refillSlots( $id, array &$procSlots, array $prioMap, array $pending ) {
		$free = 0;
		$new = 0;
		foreach ( $procSlots as $slot => &$procSlot ) {
			$status = $procSlot['handle']
				? proc_get_status( $procSlot['handle'] )
				: false;
			if ( $status && $status['running'] ) {
				$maxReal = isset( $this->maxReal[$procSlot['type']] )
					? $this->maxRealMap[$procSlot['type']]
					: $this->maxRealMap['*'];
				if ( ( time() - $procSlot['stime'] ) >= $maxReal ) {
					$cmd = $procSlot['cmd'];
					$this->error( "Runner loop $id process in slot $slot timed out:\n$cmd." );
					$this->closeRunner( $id, $slot, $procSlot, SIGKILL );
				} else {
					continue; // slot is busy
				}
			} elseif ( $status && !$status['running'] ) {
				if ( $status['exitcode'] != 0 ) {
					$error = stream_get_contents( $procSlot['pipes'][2] );
					$this->error( "Runner loop $id process in slot $slot " .
						"gave status '{$status['exitcode']}':\n\t$error." );
				}
				$this->closeRunner( $id, $slot, $procSlot );
			} elseif ( !$status && $procSlot['handle'] ) {
				$this->error( "Runner loop $id process in slot $slot gave no status." );
				$this->closeRunner( $id, $slot, $procSlot );
			}
			++$free;
			$queue = $this->selectQueue( $id, $slot, $prioMap, $pending );
			if ( !$queue ) {
				break;
			}
			// Spawn a job runner for this loop ID
			$highPrio = $prioMap[$id]['high'];
			$this->spawnRunner( $id, $slot, $highPrio, $queue, $procSlot );
			++$new;
		}

		return array( $free, $new );
	}

	/**
	 * @param integer $id
	 * @param integer $slot
	 * @param array $prioMap
	 * @param array $pending
	 * @return array|boolean
	 */
	protected function selectQueue( $id, $slot, array $prioMap, array $pending ) {
		$include = array();
		$exclude = array();
		foreach ( $this->loopMap[$id]['types'] as $type ) {
			// "*" means "all current queues"
			if ( $type === '*' ) {
				$include = array_merge( $include, array_keys( $pending ) );
			// "-" as a prefix means "exclude this queue" from "*"
			} elseif ( $type[0] === '-' ) {
				$exclude[] = substr( $type, 1 );
			// "~" as a prefix means "low priority"
			} elseif ( $type[0] === '~' ) {
				if ( $prioMap[$id]['high'] ) {
					// In high priority mode, exclude this type
					$exclude[] = substr( $type, 1 );
				} else {
					// In low priority mode, allow this type
					$include[] = substr( $type, 1 );
				}
			} else {
				$include[] = $type;
			}
		}
		$candidateTypes = array_diff( $include, $exclude );

		$candidates = array(); // list of (type, db)
		// Flatten the tree of candidates into a flat list so that a random
		// item can be selected, weighing each queue (type/db tuple) equally.
		foreach ( $pending as $type => $dbs ) {
			if ( in_array( $type, $candidateTypes ) ) {
				foreach ( $dbs as $db ) {
					$candidates[] = array( $type, $db );
				}
			}
		}
		if ( !count( $candidates ) ) {
			return false; // no jobs for this type
		}

		return $candidates[mt_rand( 0, count( $candidates ) - 1 )];
	}

	/**
	 * @param integer $id
	 * @param integer $slot
	 * @param bool $highPrio
	 * @param array $queue
	 * @param array $procSlot
	 * @return bool
	 */
	protected function spawnRunner( $id, $slot, $highPrio, array $queue, array &$procSlot ) {
		// Pick a random queue
		list( $type, $db ) = $queue;
		$encType = escapeshellarg( $type );
		$encWiki = escapeshellarg( $db );
		$encMaxTime = escapeshellarg( $highPrio ? $this->lpMaxTime : $this->hpMaxTime );
		$encMaxMem = escapeshellarg(
			isset( $this->maxMemMap[$type] ) ? $this->maxMemMap[$type] : $this->maxMemMap['*']
		);

		// Apply any HET-deploy style wrapper
		$script = $this->wrapper
			? "{$this->wrapper} runJobs.php"
			: "php maintenance/runJobs.php";

		// Make sure the runner is launched with various time/memory limits.
		// Nice the process so things like ssh and deployment scripts are fine.
		$cmd = "$script --wiki=$encWiki --type=$encType " .
			"--maxtime=$encMaxTime --memory-limit=$encMaxMem";
		if ( substr( php_uname(), 0, 7 ) !== 'Windows' ) {
			$cmd = "nice -n 19 $cmd";
		}

		$descriptors = array(
			0 => array( "pipe", "r" ), // stdin (child)
			1 => array( "pipe", "w" ), // stdout (child)
			2 => array( "pipe", "w" ) // stderr (child)
		);

		$this->debug( "Spawning runner in loop $id at slot $slot ($type, $db):\n\t$cmd." );

		// Start the runner in the background
		$procSlot['handle'] = proc_open( $cmd, $descriptors, $procSlot['pipes'] );
		fclose( $procSlot['pipes'][0] );
		unset( $procSlot['pipes'][0] ); // unused
		$procSlot['type'] = $type;
		$procSlot['cmd'] = $cmd;
		$procSlot['stime'] = time();

		if ( $procSlot['handle'] ) {
			return true;
		} else {
			$this->error( "Could not spawn process in loop $id: $cmd" );
			return false;
		}
	}

	/**
	 * @param integer $id
	 * @param integer $slot
	 * @param array $procSlot
	 * @param integer $signal
	 */
	protected function closeRunner( $id, $slot, array &$procSlot, $signal = null ) {
		if ( $procSlot['pipes'] ) {
			if ( $procSlot['pipes'][1] !== false ) {
				fclose( $procSlot['pipes'][1] );
				$procSlot['pipes'][1] = false;
			}
			if ( $procSlot['pipes'][2] !== false ) {
				fclose( $procSlot['pipes'][2] );
				$procSlot['pipes'][2] = false;
			}
		}
		if ( $procSlot['handle'] ) {
			$this->debug( "Closing process in loop $id at slot $slot" );
			if ( $signal !== null ) {
				// Tell the process to close with a signal
				proc_terminate( $procSlot['handle'], $signal );
			} else {
				// Wait for the process to finish on its own
				proc_close( $procSlot['handle'] );
			}
		}
		$procSlot['handle'] = false;
		$procSlot['type'] = null;
		$procSlot['stime'] = 0;
		$procSlot['cmd'] = null;
	}

	/**
	 * @return array
	 */
	protected function getReadyQueueMap() {
		static $map = null; // cache
		static $mapTimestamp = 0;

		$pendingDBs = array();
		if ( $map === null || $mapTimestamp < microtime( true ) - 0.5 ) {
			$conn = false;
			// Connect to the first working server on the list
			foreach ( $this->aggrSrvs as $server ) {
				$conn = $this->getRedisConn( $server );
				if ( $conn ) {
					break;
				}
			}
			if ( $conn ) {
				try {
					// Match JobQueueAggregatorRedis.php
					$map = $this->redisCmd( $conn, 'hGetAll', array( $this->getReadyQueueKey() ) );
					if ( $map === false ) {
						return $pendingDBs;
					}

					$wikiIds = array();
					$pendingDBs = array(); // (type => list of wikis)
					foreach ( $map as $key => $time ) {
						list( $type, $wiki ) = $this->dencQueueName( $key );
						$pendingDBs[$type][] = $wiki;
						$wikiIds[] = $wiki;
					}

					// Keep the list of wiki IDs up-to-date
					if ( count( $wikiIds ) ) {
						$params = array_merge( array( $this->getWikiSetKey() ), $wikiIds );
						$this->redisCmd( $conn, 'sAdd', $params );
					}
				} catch ( RedisException $e ) {
					unset( $this->conns[$server] );
				}
			}
		}

		return $pendingDBs;
	}

	/**
	 * Recycle or destroy any jobs that have been claimed for too long
	 * and release any ready delayed jobs into the queue. Also abandon
	 * and prune out jobs that failed too many times.
	 *
	 * @note: similar to JobQueueRedis.php periodic tasks method
	 * @return int|bool Number of jobs recycled/deleted/undelayed/abandoned (false if not run)
	 */
	protected function executeReadyPeriodicTasks() {
		$tasksRun = 0;

		// Run no more than every 5 minutes
		static $lastPeriodicTime = null;
		$lastPeriodicTime = $lastPeriodicTime ?: time() - mt_rand( 0, 300 );
		if ( ( time() - $lastPeriodicTime ) <= 300 ) {
			return false;
		}
		$lastPeriodicTime = time();

		$aConn = false;
		// Connect to the first working server on the list
		foreach ( $this->aggrSrvs as $aServer ) {
			$aConn = $this->getRedisConn( $aServer );
			if ( $aConn ) {
				break;
			}
		}

		if ( !$aConn ) {
			return $tasksRun;
		}

		static $script =
<<<LUA
		local kClaimed, kAttempts, kUnclaimed, kData, kAbandoned, kDelayed = unpack(KEYS)
		local rClaimCutoff, rPruneCutoff, rAttempts, rTime = unpack(ARGV)
		local released,abandoned,pruned,undelayed = 0,0,0,0
		-- Get all non-dead jobs that have an expired claim on them.
		-- The score for each item is the last claim timestamp (UNIX).
		local staleClaims = redis.call('zRangeByScore',kClaimed,0,rClaimCutoff)
		for k,id in ipairs(staleClaims) do
			local timestamp = redis.call('zScore',kClaimed,id)
			local attempts = redis.call('hGet',kAttempts,id)
			if attempts < rAttempts then
				-- Claim expired and attempts left: re-enqueue the job
				redis.call('lPush',kUnclaimed,id)
				redis.call('hIncrBy',kAttempts,id,1)
				released = released + 1
			else
				-- Claim expired and no attempts left: mark the job as dead
				redis.call('zAdd',kAbandoned,timestamp,id)
				abandoned = abandoned + 1
			end
			redis.call('zRem',kClaimed,id)
		end
		-- Get all of the dead jobs that have been marked as dead for too long.
		-- The score for each item is the last claim timestamp (UNIX).
		local deadClaims = redis.call('zRangeByScore',kAbandoned,0,rPruneCutoff)
		for k,id in ipairs(deadClaims) do
			-- Stale and out of attempts: remove any traces of the job
			redis.call('zRem',kAbandoned,id)
			redis.call('hDel',kAttempts,id)
			redis.call('hDel',kData,id)
			pruned = pruned + 1
		end
		-- Get the list of ready delayed jobs, sorted by readiness (UNIX timestamp)
		local ids = redis.call('zRangeByScore',kDelayed,0,rTime)
		-- Migrate the jobs from the "delayed" set to the "unclaimed" list
		for k,id in ipairs(ids) do
			redis.call('lPush',kUnclaimed,id)
			redis.call('zRem',kDelayed,id)
		end
		undelayed = #ids
		return {released,abandoned,pruned,undelayed}
LUA;

		try {
			$types = $this->redisCmd( $aConn, 'hKeys', array( $this->getQueueTypesKey() ) );
			$wikiIds = $this->redisCmd( $aConn, 'sMembers', array( $this->getWikiSetKey() ) );

			shuffle( $types );
			shuffle( $wikiIds );

			$now = time();

			$paramsByQueue = array();
			foreach ( $types as $type ) {
				$ttl = isset( $this->claimTTLMap[$type] )
					? $this->claimTTLMap[$type]
					: $this->claimTTLMap['*'];
				$attempts = isset( $this->attemptsMap[$type] )
					? $this->attemptsMap[$type]
					: $this->attemptsMap['*'];
				foreach ( $wikiIds as $wikiId ) {
					$paramsByQueue[] = array(
						'queue'  => array( $type, $wikiId ),
						'params' => array(
							"{$wikiId}:jobqueue:{$type}:z-claimed", # KEYS[1]
							"{$wikiId}:jobqueue:{$type}:h-attempts", # KEYS[2]
							"{$wikiId}:jobqueue:{$type}:l-unclaimed", # KEYS[3]
							"{$wikiId}:jobqueue:{$type}:h-data", # KEYS[4]
							"{$wikiId}:jobqueue:{$type}:z-abandoned", # KEYS[5]
							"{$wikiId}:jobqueue:{$type}:z-delayed", # KEYS[6]
							$now - $ttl, # ARGV[1]
							$now - 7 * 86400, # ARGV[2]
							$attempts, # ARGV[3]
							$now # ARGV[4]
						),
						'keys'   => 6 # number of first argument(s) that are keys
					);
				}
			}

			// Run the script on all job queue partitions...
			foreach ( $this->queueSrvs as $qServer ) {
				$qConn = $this->getRedisConn( $qServer );
				if ( !$qConn ) {
					continue; // partition down
				}

				try {
					$sha1 = $this->redisCmd( $qConn, 'script', array( 'load', $script ) );

					$this->redisCmd( $qConn, 'multi', array( Redis::PIPELINE ) );
					foreach ( $paramsByQueue as $params ) {
						$this->redisCmd( $qConn, 'evalSha',
							array( $sha1, $params['params'], $params['keys'] ) );
					}
					$res = $this->redisCmd( $qConn, 'exec' );

					$now = time();
					$mapSet = array(); // map of (queue name => timestamp)
					foreach ( $res as $i => $result ) {
						list( $qType, $qWiki ) = $paramsByQueue[$i]['queue'];
						$tasksRun += array_sum( $result );
						list( $released, $abandoned, $pruned, $undelayed ) = $result;
						if ( $released > 0 || $undelayed > 0 ) {
							$mapSet[$this->encQueueName( $qType, $qWiki )] = $now;
						}
						$this->incrStats( 'job-recycle', $qType, $released, $qWiki );
						$this->incrStats( 'job-abandon', $qType, $abandoned, $qWiki );
						$this->incrStats( 'job-undelay', $qType, $undelayed, $qWiki );
					}
				} catch ( RedisException $e ) {
					unset( $this->conns[$qServer] );
				}

				$this->redisCmd( $aConn, 'hMSet', array( $this->getReadyQueueKey(), $mapSet ) );
			}
		} catch ( RedisException $e ) {
			unset( $this->conns[$aServer] );
		}

		return $tasksRun;
	}

	/**
	 * @return string (per JobQueueAggregatorRedis.php)
	 */
	private function getReadyQueueKey() {
		return "jobqueue:aggregator:h-ready-queues:v1"; // global
	}

	/**
	 * @return string (per JobQueueAggregatorRedis.php)
	 */
	private function getQueueTypesKey() {
		return "jobqueue:aggregator:h-queue-types:v1"; // global
	}

	/**
	 * @return string
	 */
	private function getWikiSetKey() {
		return "jobqueue:aggregator:s-wikis:v1"; // global
	}

	/**
	 * @param string $type
	 * @param string $wiki
	 * @return string (per JobQueueAggregatorRedis.php)
	 */
	private function encQueueName( $type, $wiki ) {
		return rawurlencode( $type ) . '/' . rawurlencode( $wiki );
	}

	/**
	 * @param string $name
	 * @return string (per JobQueueAggregatorRedis.php)
	 */
	private function dencQueueName( $name ) {
		list( $type, $wiki ) = explode( '/', $name, 2 );

		return array( rawurldecode( $type ), rawurldecode( $wiki ) );
	}

	/**
	 * @param string $server
	 * @return Redis|boolean|array
	 */
	protected function getRedisConn( $server ) {
		// Check the listing "dead" servers which have had a connection errors.
		// Srvs are marked dead for a limited period of time, to
		// avoid excessive overhead from repeated connection timeouts.
		if ( isset( $this->downSrvs[$server] ) ) {
			$now = time();
			if ( $now > $this->downSrvs[$server] ) {
				// Dead time expired
				unset( $this->downSrvs[$server] );
			} else {
				// Server is dead
				return false;
			}
		}

		if ( isset( $this->conns[$server] ) ) {
			return $this->conns[$server];
		}

		try {
			$conn = new Redis();
			if ( strpos( $server, ':' ) === false ) {
				$host = $server;
				$port = null;
			} else {
				list( $host, $port ) = explode( ':', $server );
			}
			$result = $conn->connect( $host, $port, 5 );
			if ( !$result ) {
				// Mark server down for some time to avoid further timeouts
				$this->downSrvs[$server] = time() + 30;

				return false;
			}
			if ( $this->password !== null ) {
				$conn->auth( $this->password );
			}
		} catch ( RedisException $e ) {
			$this->downSrvs[$server] = time() + 30;

			return false;
		}

		if ( $conn ) {
			$conn->setOption( Redis::OPT_READ_TIMEOUT, 5 );
			$conn->setOption( Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP );
			$this->conns[$server] = $conn;

			return $conn;
		} else {
			return false;
		}
	}

	/**
	 * @param Redis $conn
	 * @param string $cmd
	 * @param array $args
	 * @return mixed
	 */
	protected function redisCmd( Redis $conn, $cmd, array $args = array() ) {
		$conn->clearLastError();
		$res = call_user_func_array( array( $conn, $cmd ), $args );
		if ( $conn->getLastError() ) {
			// Make all errors be exceptions instead of "most but not all".
			// This will let the caller know to reset the connection to be safe.
			throw new RedisException( $conn->getLastError() );
		}
		return $res;
	}

	/**
	 * @param string $event
	 * @param string $type
	 * @param integer $delta
	 * @param string $wiki
	 * @return void
	 */
	protected function incrStats( $event, $type, $delta = 1, $wiki = null ) {
		if ( !$this->statsdHost || $delta == 0 ) {
			return; // nothing to do
		}

		static $format = "%s:%s|c\n";
		$packet = sprintf( $format, "jobrunner.$event.$type.$wiki", $delta );

		if ( !function_exists( 'socket_create' ) ) {
			$this->debug( 'No "socket_create" method available.' );
			return;
		}

		static $socket = null;
		if ( !$socket ) {
			$socket = socket_create( AF_INET, SOCK_DGRAM, SOL_UDP );
		}

		socket_sendto(
			$socket,
			$packet,
			strlen( $packet ),
			0,
			$this->statsdHost,
			$this->statsdPort
		);
	}

	/**
	 * @param string $s
	 */
	protected function debug( $s ) {
		if ( $this->verbose ) {
			print "$s\n";
		}
	}

	/**
	 * @param string $s
	 */
	protected function notice( $s ) {
		print date( DATE_ISO8601 ) . ": $s\n";
	}

	/**
	 * @param string $s
	 */
	protected function error( $s ) {
		fwrite( STDERR, "$s\n" );
	}
}
